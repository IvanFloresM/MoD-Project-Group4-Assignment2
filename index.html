<!DOCTYPE html>
<html lang="en">
<head>

  <!-- Basic Page Needs–– -->
  <meta charset="utf-8">
  <title>MoD Group Project</title>
  <meta name="description" content="">
  <meta name="Ivan Flores Martinez" content="">

  <!-- Mobile Specific Metas -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- FONT -->
  <link href="https://fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.10.2/css/all.min.css">

  <!-- Mobile Specific Metas -->
  <meta name="viewport" content="width=device-width, initial-scale=1">


  <!-- CSS -->
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">
  <link rel="stylesheet" href="css/customize.css">

  <!-- Load d3.js -->
  <script src="https://d3js.org/d3.v4.js"></script>
  <!-- D3 v3 -->
  <script src="https://d3js.org/d3.v3.min.js"></script>

  <!-- Color Scale -->
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

  <!-- Mapbox links -->

  <script src='https://api.mapbox.com/mapbox-gl-js/v2.1.1/mapbox-gl.js'></script>
  <link href='https://api.mapbox.com/mapbox-gl-js/v2.1.1/mapbox-gl.css' rel='stylesheet' />

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="images/favicon.png">

  <style>
    .imgContainer{
      float:left;
      margin-right:5px;
    }

    .text{
    text-align:justify;
    }

    .center {
      display: block;
      margin-left: auto;
      margin-right: auto;
      width: 50%;
    }

    .center-text {
      margin-left: auto;
      margin-right: auto;
      width: 100%;
    }
  </style>

</head>
<body>
  <div class="container one-bottom" style="margin-top: 50px">
    <div class="ten columns">
      <h3 class="text"><STRONG>The impact of COVID-19 on New York City Bike </h3></STRONG>
      <p>
        ARCH 6306/6050, DSBA 6010, ITIS 8010/6010: Wednesdays 6pm-8:30pm, Taught Online
        <br>
        Ivan Flores Martinez | Bianca Moore | Jake D'Antoni | Samrhiti Kamat
        <br>
      </p>
    </div>
    <div class="two columns">
      <a href="https://urbansynergeticslab.net/"><img class="scale-with-grid" src="covid_bike.jpg"></strong></a>
    </div>
    <div class="twelve columns">
      <h5>Research Question</h5>
      <h4 class="text"><strong>How have the peak hours and numbers of trips effected demand of the city bikes in NYC in 2020?</h4>
      <h5>Background</h5>
      <p class="text">With the recent outbreak of the coronavirus pandemic in 2020, we aim to compare data on bike sharing services in New York City from the years 2019 and 2020 to see if there are any conclusions that can be drawn relating to the pandemic’s effect on the CitiBike NYC services. Although correlation does not prove causation, we believe that examining these two years and comparing the data will allow us to make assumptions based on the data found. </p>
      <h5 style="text-align: center"><em>Bike lanes and stations</em></h5>
         <div id='map' style='width: 950px; height: 500px; align=middle;'> </div>
      <p class="center-text">Note: The map above shows 2020 bike lanes and stations highlighted in red. Clusters of stations and bike lane locations indicate areas where bike traffic is high.</p>
      <br>
      <p class="text">The data that was collected and observed included variables relating to location, time, number of trips and user type. COVID-19 shutdowns began in March of 2020 in the state of New York. The number of COVID-19 cases in NYC today amount to over 676,000 with over 28,000 deaths. Due to the amount of cases in NYC, we found it important to determine the effects of the pandemic on the city's shared bike system. We collected data from New York Public Health repository and added it to our analysis to observe impact.
        With our question in specific we aimed at looking at location and the timeline of the trips. On looking at the graphs concerning peak hours, it is observed that not only did the peak hours fluctuate but also the number of trips varied. Conclusions can be drawn relating to the number of trips, where there was a sharp decrease in March & April of 2020 when national lockdown began. Comparatively, in 2019 there was a sharp increase in these months. In addition, peak hours during 2019 and 2020 both show early morning and evening hours as high points, alluding to the argument that bike sharing services were used primarily for commuting to and from work.</p>
    </div>
      <div class="image123">
        <div class="imgContainer">
          <p class="center"><em>Covid cases vs number of trips in NYC in 2020</em></p>
          <img src="Trips vs Case Count.png" height="470" width="470"/>
        </div>
        <div class="imgContainer">
          <p class="center"><em>Covid cases in New York City in 2020</em></p>
          <img class="middle-img" src="dates vs cases.png" height="470" width="470"/>
        </div>
      </div>
      <br>
    <br>
    <br>
    <div class="twelve columns">
      <p class="text">Daily trips in 2020 showed greater variance with a minimum number of trips per day at 3 and a maximum at 2796, while 2019 showed a minimum of 196 trips per day and a max at 1925. Overall, the median trips per day is at 1142, higher than the 2020 median which sits at 883.5 trips per day. There are clear differences between the years 2019 and 2020 that show unusual trends in 2020, confirming our belief that bike share trips were affected by the corona virus outbreak. Nonetheless, the bike sharing service data shows that it is a resilient transportation service.</p>
      <p class="text">The average number of trips per day shows that in 2019, there were two peaks - in the morning and afternoon. This alludes to the conclusion that shared bike systems were used for commuting to and from work. Comparatively, the data from 2020 shows the absence of a morning peak in trips, possibly due to change in working patterns and transition to working-from-home. However, there is still a peak in the afternoon, showing that people continued to use shared bike systems in the evening for pleasure purposes. As seen in the graphs, the demand and the patterns show the usage reducing by half in the first peak (about 8am) and reduced in a lesser intensity at the second peak (between 7pm - 8pm).</p>
    </div>
    <div class="image123">
      <div class="imgContainer">
        <p class="center"><em>Average number of trips per hours of the day 2019</em></p>
        <img src="Average number of trips per hours of the day 2019.png" height="475" width="475"/>
      </div>
      <div class="imgContainer">
        <p class="center"><em>Average number of trips per hours of the day 2020</em></p>
        <img class="middle-img" src="Average number of trips per hours of the day 2020.png" height="475" width="475"/>
      </div>
      </br>
    </div>
    </br>
    <p class="text"> Citi Bike share program, has seen demand surge 67 percent this month: Between March 1 and March 11, there were a total of 517,768 trips compared with 310,132 trips during the same period the year before.</p>
    </br>
    <p class="center"><em>Number of trips in NYC in 2020 and 2019</em></p>
    <div id="my_dataviz" align="middle" ></div>

    //Create chord SVG
    <div class="container" >
      <div class="twelve columns one-bottom">
        <p>The following graph shows the change in bike stations for all trips</p>
      </div>
      <div class="row one-bottom">
        <button class="four columns" onClick="create_svg_group('chord_05', 800, 800, xPos + outerRadius, yPos + outerRadius)">Create SVG</button>
        <button class="four columns" onClick="remove_svg('chord_05')">Remove SVG</button>
        <button class="four columns" onClick="redraw_v2(d3.select('#chord_05').selectAll('svg').select('g'))">Redraw</button>
      </div>
      <div id="chord_05" class="twelve columns">
      </div>
    </div>
    <br>
      <h3>References</h3>
      <ol>
        <li class="text">Hu, Winnie. “A Surge in Biking to Avoid Crowded Trains in N.Y.C.” The New York Times. The New York Times, March 14, 2020. https://www.nytimes.com/2020/03/14/nyregion/coronavirus-nyc-bike-commute.html</li>
        <li class="text">Calgary, Open. “Bicycle Routes.” NYC Open Data. Accessed February 17, 2021. https://data.cityofnewyork.us/Transportation/Bicycle-Routes/7vsa-caz7.</li>
        <li class="text">Tedeschi, Alexander. “Rebalancing Citi Bike : a Geospatial Analysis of Bike Share Redistribution in New York City.” RUN, February 26, 2016. https://run.unl.pt/handle/10362/17842?locale=en.</li>
        <li class="text">Teixeira, João Filipe, and Miguel Lopes. “The Link between Bike Sharing and Subway Use during the COVID-19 Pandemic: The Case-Study of New York's Citi Bike.” Transportation Research Interdisciplinary Perspectives. Elsevier, July 8, 2020. https://www.sciencedirect.com/science/article/pii/S2590198220300774.</li>
      </ol>
    </div>
  </div>

  <div class="container one-bottom" >
    <h3>Team & Contributions</h3>
    <h5>Ivan Flores Martinez</h5>
    <p class="text">Ivan Flores took the lead with regards to setting up the github website, cleaning data, and creating graphs for the webpage. He took charge in putting together the github website.</p>
    <h5>Bianca Moore</h5>
    <p class="text">Bianca Moore produced multiple graphs for the webpage and worked in RStudio to clean data. She also aided in putting together the github website.</p>
    <h5>Jake D'Antoni</h5>
    <p class="text">Jake D'Antoni produced the bike sharing map via mapbox and aided in writing the context. He also aided in putting together the github website.</p>
    <h5>Samrhiti Kamat</h5>
    <p class="text">Samrhiti Kamat helped write the context for our paper and aided putting together the github website.</p>
  </div>
</body>
  <script>
    mapboxgl.accessToken = 'pk.eyJ1IjoiamNkYW50b25pIiwiYSI6ImNrbDc5aGFxcjFrM2wydm5yZWthajFpc3UifQ.Y3ZOqGUxmeVLmvfiUSLVDw';
    var map = new mapboxgl.Map({
    container: 'map', // container ID
    style: 'mapbox://styles/jcdantoni/ckl42vtzl2zrp17jy6oxr56k8', // style URL
    center: [-74, 40.72165072], // starting position [lng, lat]
    zoom: 11 // starting zoom
  });
  </script>
<script>
  // set the dimensions and margins of the graph
  var margin = {top: 10, right: 100, bottom: 30, left: 30},
          width = 700 - margin.left - margin.right,
          height = 500 - margin.top - margin.bottom;

  // append the svg object to the body of the page
  var svg = d3.select("#my_dataviz")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr("transform",
                  "translate(" + margin.left + "," + margin.top + ")");

  //Read the data
  d3.csv("trips_2019-2020.csv", function(data) {

    // List of groups (here I have one group per column)
    var allGroup = ["trips2019", "trips2020", "total_trips"]

    // Reformat the data: we need an array of arrays of {x, y} tuples
    var dataReady = allGroup.map( function(grpName) { // .map allows to do something for each element of the list
      return {
        name: grpName,
        values: data.map(function(d) {
          return {month: d.month, value: +d[grpName]};
        })
      };
    });
    // I strongly advise to have a look to dataReady with
    // console.log(dataReady)

    // A color scale: one color for each group
    var myColor = d3.scaleOrdinal()
            .domain(allGroup)
            .range(d3.schemeSet2);

    // Add X axis --> it is a date format
    var x = d3.scaleLinear()
            .domain([0,12])
            .range([ 0, width ]);
    svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x));

    // Add Y axis
    var y = d3.scaleLinear().nice()
            .domain([0, 100000])
            .range([ height,0]);
    svg.append("g")
            .call(d3.axisLeft(y));
//    d3.axisLeft(y)).tickValues([10000,20000,30000,40000,50000,60000,70000,80000,90000, 10000]);

    // Add the lines
    var line = d3.line()
            .x(function(d) { return x(+d.month) })
            .y(function(d) { return y(+d.value) })
    svg.selectAll("myLines")
            .data(dataReady)
            .enter()
            .append("path")
            .attr("class", function(d){ return d.name })
            .attr("d", function(d){ return line(d.values) } )
            .attr("stroke", function(d){ return myColor(d.name) })
            .style("stroke-width", 4)
            .style("fill", "none")

    // Add the points
    svg
            // First we need to enter in a group
            .selectAll("myDots")
            .data(dataReady)
            .enter()
            .append('g')
            .style("fill", function(d){ return myColor(d.name) })
            .attr("class", function(d){ return d.name })
            // Second we need to enter in the 'values' part of this group
            .selectAll("myPoints")
            .data(function(d){ return d.values})
            .enter()
            .append("circle")
            .attr("cx", function(d) { return x(d.month) } )
            .attr("cy", function(d) { return y(d.value) } )
            .attr("r", 8)
            .attr("stroke", "white")

    // Add a label at the end of each line
    svg
            .selectAll("myLabels")
            .data(dataReady)
            .enter()
            .append('g')
            .append("text")
            .attr("class", function(d){ return d.name })
            .datum(function(d) { return {name: d.name, value: d.values[d.values.length - 1]}; }) // keep only the last value of each time series
            .attr("transform", function(d) { return "translate(" + x(d.value.month) + "," + y(d.value.value) + ")"; }) // Put the text at the position of the last point
            .attr("x", 12) // shift the text a bit more right
            .text(function(d) { return d.name; })
            .style("fill", function(d){ return myColor(d.name) })
            .style("font-size", 20)

    // Add a legend (interactive)
    svg
            .selectAll("myLegend")
            .data(dataReady)
            .enter()
            .append('g')
            .append("text")
            .attr('x', function(d,i){ return 30 + i*130})
            .attr('y', 10)
            .text(function(d) { return d.name; })
            .style("fill", function(d){ return myColor(d.name) })
            .style("font-size", 20)
            .on("click", function(d){
              // is the element currently visible ?
              currentOpacity = d3.selectAll("." + d.name).style("opacity")
              // Change the opacity: from 0 to 1 or from 1 to 0
              d3.selectAll("." + d.name).transition().style("opacity", currentOpacity == 1 ? 0:1)

            })
  })
</script>

<script type="text/javascript">

  // STEP 1: Setup
  var nTrips = 30;
  var nStations = 6;

  var margin = 50;
  var width = 600;

  var xPos = margin;
  var yPos = margin;

  var thickness = 30;
  var diameter = width - 2*margin;
  var outerRadius = diameter / 2;
  var innerRadius = outerRadius - thickness;

  var color = d3.scale.linear()
          .domain([0, nStations])
          .range([d3.rgb(255,0,0), d3.rgb(50,0,0)]);


  // STEP 2: Create/Get Data and OD Matrix
  var tripData = createTripData(nTrips, nStations);
  var stationData = createStationData(nStations);
  var od_matrix = createMatrix(tripData, stationData);



  // STEP 3: Create Chord Layout
  var chordLayout = d3.layout.chord()
          .matrix(od_matrix)
          .padding(0.05)
          .sortGroups(d3.descending); // You can also pass custom sorting functions that compare two objects like function(a,b){...}
  // About d3.layout.chord():
  // d3.layout.chord() is a D3 layout object. Read about D3 Layouts here: https://d3indepth.com/layouts/ and about Chord Layout here: https://d3-wiki.readthedocs.io/zh_CN/master/Chord-Layout/
  // Once the Chord Layout is being assigned an OD matrix ( d3.layout.chord().matrix(od_matrix) ), it can return groups and chords arrays as follows:
  // function chordLayout.groups() returns the groups
  // function chordLayout.chords() returns the chords


  // STEP 4: Create SVG Shape Generators for arcs and chords
  var arc = d3.svg.arc()
          .innerRadius(innerRadius)
          .outerRadius(outerRadius);
  // About d3.svg.arc():
  // d3.svg.arc() is an SVG Shape Generator. Read more about SVG Shape Generators here: https://d3indepth.com/shapes/
  // d3.svg.arc() takes a group object as an input and returns its path
  // To define an arc SVG Shape Generator you first need to define the inner and outer radii
  // function chordLayout.groups() returns an array with all groups (e.g. arc sectors)
  // each group object contains a start angle, an end angle, an index number, and a value.
  // for example, arc(chordLayout.groups()[2]) returns the path of the third group


  var chord = d3.svg.chord()
          .radius(innerRadius - 5);
  // About d3.svg.chord():
  // d3.svg.chord() is also an SVG Shape Generator. It takes a chord object as an input and returns its path
  // To define a chord SVG Shape Generator you first need to define the radious
  // chordLayout.chords() returns an array with all chords
  // each chord object consists of a source and a target, and each of the source and target is a segment of a group with its own start angle and end angle
  // for example, chord(chordLayout.chords()[12]) returns the path of the 13th chord


  // STEP 5: Create the SVG and an empty group "g" to contain the Arc and Chord Shapes that you will be generating
  var svgGroup = d3.select("#chord_01").append("svg")
          .attr("width", 800)
          .attr("height", 800)
          .append("g")
          .attr("transform", "translate(" + (xPos + outerRadius) + "," + (yPos + outerRadius) + ")");
  // Create an SVG element in the body of the html page, and define its width and height
  // Then, append an empty "group" (g) inside it, and determine its X,Y origin
  // You need this g element in order to start embedding paths inside it and consider them as a single object.



  // STEP 6: Draw Arcs/Groups
  svgGroup.selectAll(".group")
          .data(chordLayout.groups())
          .enter()
          .append("g")
          .attr("class", "group")
          .append("path")
          .attr("id", function(d, i) { return "group" + i; })
          .style("fill", function(d) { return color(d.index); })
          .style("stroke", d3.rgb(0,0,0))
          .style("stroke-width", 1)
          .attr("d", function(d) { return arc(d)})
          .on("hover", function (d,i) {
          })
          .on("click", function (d,i) {
          });

  // STEP 7: Draw Chords
  svgGroup.selectAll(".chord")
          .data(chordLayout.chords())
          .enter()
          .append("path")
          .attr("class", "chord")
          .style("fill", d3.rgb(180,180,180))
          .style("stroke", d3.rgb(180,180,180).darker(3))
          .style("opacity", 0.5)
          // .style("opacity", function(d){
          // 	if(d.source.index==2 || d.target.index==2)
          // 		return 1;
          // 	else
          // 		return 0.1
          // })
          .attr("d", function(d) { return chord(d)} )
          .on("hover", function (d) {
          })
          .on("click", function (d,i) {
          });




  var svg2 = d3.select("#chord_02").append("svg")
          .attr("width", 800)
          .attr("height", 800)
          .append("g")
          .attr("transform", "translate(" + (xPos + outerRadius) + "," + (yPos + outerRadius) + ")");
  svg2.selectAll(".group")
          .data(chordLayout.groups())
          .enter()
          .append("g")
          .attr("class", "group")
          .append("path")
          .attr("id", function(d, i) { return "group" + i; })
          .style("fill", function(d) { return color(d.index); })
          .style("stroke", d3.rgb(0,0,0))
          .style("stroke-width", 1)
          .attr("d", function(d) { return arc(d)});


  var svg3 = d3.select("#chord_03").append("svg")
          .attr("width", 800)
          .attr("height", 800)
          .append("g")
          .attr("transform", "translate(" + (xPos + outerRadius) + "," + (yPos + outerRadius) + ")");
  svg3.selectAll(".group")
          .data(chordLayout.groups())
          .enter()
          .append("g")
          .attr("class", "group")
          .append("path")
          .attr("id", function(d, i) { return "group" + i; })
          .style("fill", function(d) { return color(d.index); })
          .style("stroke", d3.rgb(0,0,0))
          .style("stroke-width", 1)
          .attr("d", function(d) { return arc(d)});
  svg3.selectAll(".chord")
          .data(chordLayout.chords())
          .enter()
          .append("path")
          .attr("class", "chord")
          .style("fill", d3.rgb(180,180,180))
          .style("stroke", d3.rgb(180,180,180).darker(3))
          .style("opacity", 0.5)
          .attr("d", function(d) { return chord(d)} );



  /********************/
  /********************/
  /***** FUNCTIONS ****/
  /********************/
  /********************/


  function get_nStations() {
    return 4 + Math.round(Math.random()*10);
  }
  function get_nTrips(nStations) {
    return nStations*10;
  }

  function createTripData(nTrips, nStations){
    var trips = [];
    for(var i=0; i<nTrips; i++){
      var origin_index = Math.floor(Math.random() * nStations);
      var destination_index = Math.floor(Math.random() * nStations);
      trips.push({
        start_station: origin_index,
        end_station: destination_index
      })
    }
    return trips;
  }
  function createStationData(nStations){
    var stations=[];
    for(var i=0; i<nStations; i++){
      stations.push({
        name: i
      })
    }
    return stations;
  }

  function createMatrix(tripData, stationData){
    var indexByNameTrip = d3.map();
    var nameByIndexTrip = d3.map();
    var n = 0;
    tripData.forEach(function(d) {
      if (!indexByNameTrip.has(d.start_station)) {
        nameByIndexTrip.set(n, d.start_station);
        indexByNameTrip.set(d.start_station, n++);
      }

    });

    var indexByNameStation = d3.map();
    var nameByIndexStation = d3.map();
    var j = 0;
    stationData.forEach(function(d) {
      if (!indexByNameStation.has(d.name)) {
        nameByIndexStation.set(j, d.name);
        indexByNameStation.set(d.name, j++);
      }
    });

    //Create the OD matrix
    var od_matrix = [];
    tripData.forEach(function(d) {
      var  startStationIndex = indexByNameTrip.get(d.start_station);
      var  endStationIndex = indexByNameTrip.get(d.end_station);
      if (!od_matrix[startStationIndex]) {
        od_matrix[startStationIndex] = [];
        for (var i = 0; i < n; i++) {
          od_matrix[startStationIndex][i] = 0;
        }
      }
      od_matrix[startStationIndex][endStationIndex]++;;
    });
    return od_matrix;
  }

  function create_svg_group(div_id, svg_width, svg_height, svg_xPos, svg_yPos){
    var svg_group = d3.select("#"+div_id).append("svg")
            .attr("width", svg_width)
            .attr("height", svg_height)
            .append("g")
            .attr("transform", "translate(" + svg_xPos + "," + svg_yPos + ")");
    return svg_group;
  }

  function remove_svg(div_id){
    d3.select("#"+div_id).selectAll("svg").remove();
  }

  function redraw(svg_group){
    // Get or Generate data
    var nStations = get_nStations();
    var nTrips = get_nTrips(nStations);

    var tripData = createTripData(nTrips, nStations);
    var stationData = createStationData(nStations);
    var od_matrix = createMatrix(tripData, stationData);

    // Apply layout to data
    chordLayout
            .matrix(od_matrix)
            .sortGroups(d3.descending);

    // Update()
    update(svg_group, chordLayout.groups(), chordLayout.chords())
  }

  function update(svg_group, arc_data, chord_data){
    // Arcs
    // Step 1: Bind data to arcs
    var arcs = svg_group
            .selectAll(".arc")
            .data(arc_data);

    // Step 2: Append any new arcs if needed
    arcs
            .enter()
            .append("path")
            .attr("class", "arc");

    // Step 3: Remove any excessive arcs if needed
    arcs
            .exit()
            .remove();

    // Step 4: Modify the arcs based on their bound data
    arcs
            .attr("id", function(d, i) { return "arc_" + i; })
            .style("fill", function(d) { return color(d.index); })
            .style("stroke", d3.rgb(0,0,0))
            .style("stroke-width", 1)
            .attr("d", function(d) { return arc(d)});


    // Chords
    // STEP 1: Bind data to chords
    var chords = svg_group
            .selectAll(".chord")
            .data(chord_data);

    // Step 2: Append any new chords if needed
    chords
            .enter()
            .append("path")
            .attr("class", "chord");

    // Step 3: Remove any excessive chorsa if needed
    chords
            .exit()
            .remove();

    // Step 4: Modify the chords based on their bound data
    chords
            .attr("id", function(d, i) { return "chord_" + i; })
            .style("fill", d3.rgb(180,180,180))
            .style("stroke", d3.rgb(180,180,180).darker(3))
            .style("opacity", 0.5)
            .attr("d", function(d) { return chord(d)} )

  }

  function update_v2(svg_group, arc_data, chord_data){

    // Arcs
    // Step 1: Bind data to arcs
    var arcs = svg_group
            .selectAll(".arc")
            .data(arc_data);

    // Step 2: Append any new arcs if needed
    arcs
            .enter()
            .append("path")
            .attr("class", "arc");

    // Step 3: Remove any excessive arcs if needed
    arcs
            .exit()
            .remove();

    // Step 4: Modify the arcs based on their bound data
    arcs
            .attr("id", function(d, i) { return "arc_" + i; })
            .style("fill", function(d) { return color(d.index); })
            .style("stroke", d3.rgb(0,0,0))
            .style("stroke-width", 1)
            .attr("d", function(d) { return arc(d)});


    // Chords
    // STEP 1: Bind data to chords
    var chords = svg_group
            .selectAll(".chord")
            .data(chord_data);

    // Step 2: Append any new chords if needed
    chords
            .enter()
            .append("path")
            .attr("class", "chord");

    // Step 3: Remove any excessive chorsa if needed
    chords
            .exit()
            .remove();

    // Step 4: Modify the chords based on their bound data
    chords
            .attr("id", function(d, i) { return "chord_" + i; })
            .style("fill", d3.rgb(180,180,180))
            .style("stroke", d3.rgb(180,180,180).darker(3))
            .style("opacity", 0.5)
            .attr("d", function(d) { return chord(d)} )


    //TickGroups
    // Step 1: Bind data to tick groups
    var tickGroups = svg_group
            .selectAll(".tickGroups")
            .data(arc_data);

    // Step 2: Append any new tick groups if needed
    tickGroups
            .enter()
            .append("g")
            .attr("class", "tickGroups");

    // Step 3: Remove any excessive tick groups if needed
    tickGroups
            .exit()
            .remove();


    //Ticks
    // Step 1: Bind data
    var ticks = tickGroups
            .selectAll("g")
            .data(groupTicks);

    // Step 2: Append any new elements if needed
    // SubStep 2.1: Append any new ticks if needed
    var tick = ticks
            .enter()
            .append("g");

    // SubStep 2.2: Within each tick append any new lines if needed
    tick
            .append("line")
            .attr("x1", 1)
            .attr("y1", 0)
            .attr("x2", 10)
            .attr("y2", 0)
            .style("stroke", "#000");

    // SubStep 2.3: Within each tick append any new text if needed
    tick
            .append("text")
            .attr("x", 15)
            .attr("font-size", "11px")
            .attr("dy", ".35em");


    // Step 3: Remove any excessive elements if needed
    ticks
            .exit()
            .remove();


    // Step 4: Modify elements based on their bound data
    ticks
            .attr("transform", function(d) {
              return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
                      + "translate(" + (outerRadius + 10) + ",0)";
            });

    ticks
            .selectAll("text")
            .attr("transform", function(d) { return d.angle > Math.PI ? "rotate(180)translate(-30)" : null; })
            .style("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
            .text(function(d) { return d.label; });

  }


  function redraw_v2(svg_group){
    // Get or Generate data
    var nStations = get_nStations();
    var nTrips = get_nTrips(nStations);

    var tripData = createTripData(nTrips, nStations);
    var stationData = createStationData(nStations);
    var od_matrix = createMatrix(tripData, stationData);

    // Apply layout to data
    chordLayout
            .matrix(od_matrix)
            .sortGroups(d3.descending);


    // Update()
    update_v2(svg_group, chordLayout.groups(), chordLayout.chords());
  }

  // Returns an array of tick angles and labels, given a group.
  function groupTicks(d,i) {
    var k = (d.endAngle - d.startAngle) / (d.value);
    return d3.range(0, d.value,1).map(function(v, i) {
      return {
        angle: v * k + d.startAngle,
        label: i % 5 ? null : v  + "%"
      };
    });
  }
</script>
</html>
